<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Create your own test · PermutationTests</title><meta name="title" content="Create your own test · PermutationTests"/><meta property="og:title" content="Create your own test · PermutationTests"/><meta property="twitter:title" content="Create your own test · PermutationTests"/><meta name="description" content="Documentation for PermutationTests."/><meta property="og:description" content="Documentation for PermutationTests."/><meta property="twitter:description" content="Documentation for PermutationTests."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="PermutationTests logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="PermutationTests logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PermutationTests</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">PermutationTests.jl</a></li><li><a class="tocitem" href="../about/">About</a></li><li><a class="tocitem" href="../PermutationTests/">Main Module</a></li><li><a class="tocitem" href="../univariate tests/">Univariate tests</a></li><li><a class="tocitem" href="../multiple comparisons tests/">Multiple comparisons tests</a></li><li><a class="tocitem" href="../package tests/">Package tests</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><span class="tocitem">Extras</span><ul><li><a class="tocitem" href="../statistics/">Statistics</a></li><li><a class="tocitem" href="../test statistics/">Test statistics</a></li><li class="is-active"><a class="tocitem" href>Create your own test</a><ul class="internal"><li><a class="tocitem" href="#Index-of-examples"><span>Index of examples</span></a></li><li><a class="tocitem" href="#Using-existing-tests"><span>Using existing tests</span></a></li><li><a class="tocitem" href="#Defining-new-test-statistics"><span>Defining new test statistics</span></a></li><li><a class="tocitem" href="#Useful-functions-for-creating-your-own-tests"><span>Useful functions for creating your own tests</span></a></li></ul></li><li><a class="tocitem" href="../chose a test/">Chose a Test</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Extras</a></li><li class="is-active"><a href>Create your own test</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Create your own test</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/PermutationTests.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/master/docs/src/create your own test.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Create-your-own-test"><a class="docs-heading-anchor" href="#Create-your-own-test">Create your own test</a><a id="Create-your-own-test-1"></a><a class="docs-heading-anchor-permalink" href="#Create-your-own-test" title="Permalink"></a></h1><p>This page illustrates how you can create <strong>univariate</strong> and <strong>multiple comparisons</strong> permutation tests besides those already supported by <em>PermutationsTests.jl</em>.</p><p>Good knowledge and understanding of the whole documentation is required for continuing reading this page, including the <strong>Extras</strong> pages.</p><p>There are two ways you can extend the capability of <em>PermutationTests.jl</em>.</p><ul><li><p>The first, very simple, but limited, is by using existing tests with particular data input.</p></li><li><p>The second, which needs a little development, but is much more general, allows you to create new tests defining your own test statistics.</p></li></ul><p>The illustration proceeds by examples of increasing complexity.</p><h2 id="Index-of-examples"><a class="docs-heading-anchor" href="#Index-of-examples">Index of examples</a><a id="Index-of-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Index-of-examples" title="Permalink"></a></h2><table><tr><th style="text-align: center">Serial</th><th style="text-align: left">Examples</th></tr><tr><td style="text-align: center">1</td><td style="text-align: left"><a href="#Example-1:-univariate-autocorrelation-test">Univariate autocorrelation test</a></td></tr><tr><td style="text-align: center">2</td><td style="text-align: left"><a href="#Example-2:-multiple-comparison-autocorrelation-test">Multiple comparison autocorrelation test</a></td></tr><tr><td style="text-align: center">3</td><td style="text-align: left"><a href="#Example-3:-univariate-t-test-for-independent-samples">Univariate t-test for independent samples</a></td></tr><tr><td style="text-align: center">4</td><td style="text-align: left"><a href="#Example-4:-multiple-comparison-correlation-test">Multiple comparison correlation test</a></td></tr><tr><td style="text-align: center">5</td><td style="text-align: left"><a href="#Example-5:-univariate-Chatterjee-correlation">Univariate Chatterjee correlation</a></td></tr><tr><td style="text-align: center">6</td><td style="text-align: left"><a href="#Example-6:-multiple-comparisons-Chatterjee-correlation">Multiple comparisons Chatterjee correlation</a></td></tr><tr><td style="text-align: center">7</td><td style="text-align: left"><a href="#Example-7:-univariate-distance-correlation">Univariate distance correlation</a></td></tr><tr><td style="text-align: center">8</td><td style="text-align: left"><a href="#Example-8:-multiple-comparison-distance-correlation">Multiple comparison distance correlation</a></td></tr></table><h2 id="Using-existing-tests"><a class="docs-heading-anchor" href="#Using-existing-tests">Using existing tests</a><a id="Using-existing-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Using-existing-tests" title="Permalink"></a></h2><p>The approach for constructing univariate and multiple comparisons tests is illustrated by creating tests for the <strong>autocorrelation</strong>, which are not in the API of the package.</p><hr/><h3 id="Example-1:-univariate-autocorrelation-test"><a class="docs-heading-anchor" href="#Example-1:-univariate-autocorrelation-test">Example 1: univariate autocorrelation test</a><a id="Example-1:-univariate-autocorrelation-test-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-univariate-autocorrelation-test" title="Permalink"></a></h3><p>As an example, let us detect the presence of autocorrelation at lag 1, similar to what the  <a href="https://en.wikipedia.org/wiki/Durbin%E2%80%93Watson_statistic">Durbin-Watson test</a> does.</p><p><em>PermutationTests.jl</em> implements the Pearson product moment correlation statistic and a test for it. We can then test the null hypothesis that the autocorrelation at lag 1 is equal to zero by performing a correlation test on a data vector <code>x</code> and a lagged version of itself <code>y</code>.</p><p>This is simply achieved by calling the <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> function, which ultimately performs all  <a href="../univariate tests/#Univariate-tests">univariate tests</a> implemented in the package.</p><p>First, let us create some data autorrelated at lag 1 to get a working example:</p><pre><code class="language-julia hljs">using PermutationTests

N=300
data=randn(N) 
for i=2:length(data)
  data[i-1]=data[i-1]+data[i]
end

# Data and lagged version of the data
x=data[1:end-1]
y=data[2:end]</code></pre><p>Our univariate test on autocorrelation is obtained with</p><pre><code class="language-julia hljs">t = _permTest!(copy(x), y, N-1, PearsonR(), PearsonR())</code></pre><p>NB: we pass a copy of <code>x</code> as this vector will be permuted. </p><p>If we wish to wrap the test in a friendly function, we can write</p><pre><code class="language-julia hljs">autocorTest(x; kwargs...) = 
  _permTest!(x[1:end-1], x[2:end], length(x)-1, PearsonR(), PearsonR(); kwargs...)</code></pre><p>The test will be executed then simply as</p><pre><code class="language-julia hljs">t2 = autocorTest(data)</code></pre><p>By default the test is bi-directional, thus the above call is a test for the autocorrelation regardless its sign. Our function <code>autocorTest</code> accepts all optional keyword arguments of the <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> function, thus we can easily obtain exact or approximate tests with a specified number of permutations, left- or right-directional tests, etc. </p><hr/><h3 id="Example-2:-multiple-comparison-autocorrelation-test"><a class="docs-heading-anchor" href="#Example-2:-multiple-comparison-autocorrelation-test">Example 2: multiple comparison autocorrelation test</a><a id="Example-2:-multiple-comparison-autocorrelation-test-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-multiple-comparison-autocorrelation-test" title="Permalink"></a></h3><p>With the same ease, we can test simultaneously the autocorrelation at several lags using the  multiple comparison version of the correlation test.</p><p>This is achieved by calling the <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a>, which ultimately performs all  <a href="../multiple comparisons tests/#Multiple-comparisons-tests">multiple comparisons tests</a> implemented in the package. Now we craete a vector <code>x</code> and a vector <code>Y</code> holding as many lagged versions of <code>x</code> as we wish to test:</p><p>Let us create some data autorrelated at lag 1 and 2 to get a working example:</p><pre><code class="language-julia hljs">using PermutationTests

N=300
data=randn(N) 
for j=1:2, i=2:length(data)
  data[i-1]=data[i-1]+data[i]
end

# We will test lags 1 to 30
lags=1:30 
x=data[1:end-length(lags)]
Y=[data[l+1:end-length(lags)+l] for l in lags]</code></pre><p>Our muliple comparisons test on autocorrelations is</p><pre><code class="language-julia hljs">tMc = _permMcTest!(copy(x), Y, N-length(lags), PearsonR(), PearsonR())</code></pre><p>The p-values are retrived by </p><pre><code class="language-julia hljs">tMc.p # p-values for lags 1...30 </code></pre><p>Notice that the test above is different from the  <a href="https://en.wikipedia.org/wiki/Ljung%E2%80%93Box_test">Liung-Box test</a>, which is a multivariate test for a group of lags: with a multiple comparison tests we have tested each lag in the group <em>simultaneously</em>, controlling the family-wise error (FWE) rate at the nominal level (0.05 by default). Thus on the base of the p-values  <em>we can take a decision on the null hypothesis at each lag</em>.</p><p>As we have done for the univariate test, we may want to wrap the call in a friendly function. This is left as an exercise.</p><hr/><h2 id="Defining-new-test-statistics"><a class="docs-heading-anchor" href="#Defining-new-test-statistics">Defining new test statistics</a><a id="Defining-new-test-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-new-test-statistics" title="Permalink"></a></h2><p>You can create your own permutation tests based on a <em>custom test statistic</em> as long as   the permutation scheme for your test is supported by <em>PermutationTests.jl</em>.  The ability to create <strong>a test for virtually whatever test-statistic</strong> is a fine characteristics of <em>PermutationTests.jl</em> and will be illustrated below with examples of ascending complexity.</p><p>The procedure to follow is the same whether you want  to create your own <strong>univariate</strong> or <strong>multiple comparisons test</strong>. It involves two preliminary steps:</p><ol><li>define a new <a href="../PermutationTests/#Statistic"><code>Statistic</code></a> type to name the test statistic you want to use</li><li>write a method for the <a href="#PermutationTests.testStatistic"><code>testStatistic</code></a> function to compute the test statistic for both the observed and permuted data</li></ol><p>You then obtain the test just calling the <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> function for an univariate test and the <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> for a multiple comparisons test, as we will show. Two arguments of these functions are particularly important:</p><ul><li>Argument <code>asStat</code>, which determines the permutation scheme of the test. </li></ul><div class="admonition is-success"><header class="admonition-header">keep in mind</header><div class="admonition-body"><p>Four permutation schemes are implemented in the package, corresponding to four implemented groups of test-statistics. The <code>asStat</code> argument can be one of the following built-in test statistics or any test statistic belonging to the same <a href="../PermutationTests/#Statistic-groups">group</a>:</p><ul><li><code>PearsonR()</code></li><li><code>AnovaF_IS()</code></li><li><code>AnovaF_RM()</code></li><li><code>StudentT_1S()</code></li></ul><p>Refer to the documentation of <a href="../tools/#PermutationTests.genPerms"><code>genPerms</code></a> and the documentation linked therein.</p></div></div><ul><li>Argument <code>fstat</code>, which is a function applied to all observed and permuted statistic.</li></ul><div class="admonition is-success"><header class="admonition-header">keep in mind</header><div class="admonition-body"><p>Argument <code>fstat</code> of <code>_permTest!</code> by default is the <code>abs</code> julia function, which yields a bi-directional test for a test-statistic that is distributed symmetrically around zero. For such test-statistics you will use  <code>fstat=identity</code> for a right-directional test and <code>fstat=</code><a href="#PermutationTests.flip"><code>flip</code></a> for a left-directional test. Note that this may not be appropriate for your own test statistic. For example, if your test statistic is not symmetric and a right-tailed test is of interest, you must use <code>fstat=identity</code>. See below for examples.</p></div></div><div class="admonition is-warning"><header class="admonition-header">important</header><div class="admonition-body"><p>The permutation vector, which is always the first argument of the <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> function for an univariate test and of the <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> for a multiple comparisons test must correspond to the permutation yielding the observed statistic (<em>i.e.</em>, no data permutation).</p></div></div><hr/><h3 id="Example-3:-univariate-t-test-for-independent-samples"><a class="docs-heading-anchor" href="#Example-3:-univariate-t-test-for-independent-samples">Example 3: univariate t-test for independent samples</a><a id="Example-3:-univariate-t-test-for-independent-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-univariate-t-test-for-independent-samples" title="Permalink"></a></h3><p>We create a new test for the difference of the mean between two independent samples. Such a test is equivalent to the <em>Student&#39;s t-test for independent samples</em>, since the mean difference is the nominator of the t statistic and the denominator is invariant with respect to data permutation.</p><p>The permutations scheme is the same as the permutation scheme of the <code>AnovaF_IS()</code> (or <code>StudentT_IS</code>)  test statistic, hence it is supported by <em>PermutationTests.jl</em> and we can reuse it.</p><p>First, let us import <code>testStatistic</code> from <em>PermutationTests.jl</em> since we will write a new method for it:</p><pre><code class="language-julia hljs">using PermutationTests
import PermutationTests: testStatistic</code></pre><p>(1) Define a new <code>Statistic</code> type to name the test statistic you want to use</p><pre><code class="language-julia hljs">struct MeanDiff &lt;: Statistic end</code></pre><p>(2) Write a method for the <code>testStatistic</code> function to compute the mean difference, it does not matter if the data is observed or permuted. </p><p>We will input the data exactly as for the <code>AnovaF_IS()</code> (or <code>StudentT_IS</code>) statistic.  Our observations are divided in two groups. In this case, for this and equivalent statistics, data input is given as a single vector  <code>y</code> of length <span>$N1+N2$</span>, with the N1 observations followed by the N2 observations (see <a href="../univariate tests/#PermutationTests.studentTestIS"><code>studentTestIS</code></a>). </p><p>The first argument of the <code>testStatistic</code> method is <strong>always</strong> the permutation vector x,  holding in this case 1 for subjects of group 1 and 2 for subjects of group 2, that is, <code>x=[repeat ([1], N1); repeat([2], N2)]</code>. When given as input, <code>x</code> will reflect the positioning of the observed data  and for permuted data it will be a permutation thereof. </p><p>A simple implementation could be: </p><pre><code class="language-julia hljs">function testStatistic(x, y, stat::MeanDiff; kwargs...)
    # get the number of subjects in each gruoup
    ns=[count(j-&gt;j==i, x) for i=1:length(unique(x))]

    s=[0., 0.]
    @simd for i ∈ eachindex(x, y) 
        @inbounds (s[x[i]] += y[i])
    end
    return (s[1]/ns[1]) - (s[2]/ns[2]) # mean difference
end</code></pre><p>That&#39;s it. </p><p>Let&#39;s test our own test. First create some data</p><pre><code class="language-julia hljs">y=[4., 5., 6., 7., 1., 2., 3]
ns=[4, 3] # N1=4, N2=3</code></pre><p>For the permuttaion vector the dedicated function <code>membership</code> is available:</p><pre><code class="language-julia hljs">x=membership(StudentT_IS(), ns) # = [repeat ([1], N1); repeat([2], N2)]</code></pre><p>A two-directional exact test, as performed by PermutationTests.jl is </p><pre><code class="language-julia hljs">println(&quot;t-test independent samples (bi-directional) using PermutationsTest.jl: &quot;);
t1 = studentTestIS(y, ns)</code></pre><p>Let us run the test we have created. Notice that argument <code>stat</code> of <code>_permTest!</code> is <code>MeanDiff()</code>, while argument <code>asStat</code> is <code>AnovaF_IS()</code>  The default <code>fstat</code> is julia abs() function, thus the test will be bi-directional as for the test <code>t1</code> here above.</p><pre><code class="language-julia hljs">println(&quot;t-test independent samples (bi-directional) using our own statistic: &quot;);
t2 = _permTest!(copy(x), y, ns, MeanDiff(), AnovaF_IS())</code></pre><p>NB: we pass a copy of <code>x</code> as this vector will be permuted. </p><hr/><p>We now illustrate with a simple example a nice opportunity we have to write  efficient code to compute test statistics; the above implementation of the <code>testStatistic</code> function computes the group numerosity (<code>ns=[N1, N2]</code>)  at each permutation, however <code>ns</code> is invariant to permutations. </p><p>Let us rewrite the function then using the <code>cpcd</code> argument,  which will be passed to the <code>_permTest!</code> functions in order to  (optionally) pre-compute <code>ns</code>:</p><pre><code class="language-julia hljs">function testStatistic(x, y, stat::MeanDiff; cpcd=nothing, kwargs...)
    if cpcd===nothing 
        ns=[count(j-&gt;j==i, x) for i=1:length(unique(x))]
    else
        ns=cpcd
    end

    s=[0., 0.]
    @simd for i ∈ eachindex(x, y) 
        @inbounds (s[x[i]] += y[i])
    end
    return (s[1]/ns[1]) - (s[2]/ns[2]) # mean difference
end</code></pre><p>Running the test now can use the <code>cpcd</code> argument to avoid redundant computations:</p><pre><code class="language-julia hljs">t3 = _permTest!(copy(x), y, ns, MeanDiff(), StudentT_IS(); cpcd=ns) </code></pre><p>You can check that the p-values obtained by all the above tests is identical:</p><pre><code class="language-julia hljs">t1.p≈t2.p≈t3.p ? (@info &quot;It works!&quot;) : 
                 (@error &quot;It does not work!&quot;)</code></pre><p>To run a right-directional test:</p><pre><code class="language-julia hljs">t4 = _permTest!(copy(x), y, ns, MeanDiff(), StudentT_IS(); fstat = identity)</code></pre><p>To run a left-directional approximate test (see <a href="#PermutationTests._permTest!"><code>_permTest!</code></a>):</p><pre><code class="language-julia hljs">t5 = _permTest!(copy(x), y, ns, MeanDiff(), StudentT_IS(); fstat = flip, switch2rand=1)</code></pre><p>Etc. </p><p>As an exercise, wrap the test we have created in a friendly function.</p><div class="admonition is-success"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>We are not restricted to the use of a <code>cpcd</code> argument. In later examples we will show how to use  an arbitrary number of specially defined keywords in order to obtain efficient tests.</p></div></div><hr/><h3 id="Example-4:-multiple-comparison-correlation-test"><a class="docs-heading-anchor" href="#Example-4:-multiple-comparison-correlation-test">Example 4: multiple comparison correlation test</a><a id="Example-4:-multiple-comparison-correlation-test-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-multiple-comparison-correlation-test" title="Permalink"></a></h3><p>We create another version of the Pearson product-moment correlation test between a fixed variable given as a vector <code>x</code> and <span>$M$</span> variables given as a vector of <span>$M$</span> vectors <code>Y</code>. We want to test simultaneously  all correlations between <code>x</code> and <code>Y[m]</code>, for <span>$m=1...M$</span>.</p><p>The procedure to follow is the same with two differences: the function <a href="#PermutationTests.testStatistic"><code>testStatistic</code></a> will now compute  each one of the `<span>$M$</span> test statistics and we will finally call the <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> function instead of the <code>_permMcTest!</code> function.</p><p>The permutations scheme for the correlation test is the one of the <code>PearsonR()</code> statistic, hence it is supported by <em>PermutationTests.jl</em> and we can reuse it (using the appropriate <code>asStat</code> argument of <code>_permMcTest!</code>).</p><p>First, let us import <code>testStatistic</code> from <em>PermutationTests.jl</em> and what we need for the computations:</p><pre><code class="language-julia hljs">using PermutationTests
import PermutationTests: testStatistic

using LinearAlgebra: dot, ⋅ # we are going to use the dot product</code></pre><p>(1) Define a new <code>Statistic</code> type to name the test statistic you want to use, such as</p><pre><code class="language-julia hljs">struct MyPearsonR &lt;: Statistic end</code></pre><p>(2) Write a function to compute the <span>$i{th}$</span> observed and permuted test statistic. In order to obtain a faster test we will work with standardized variables, thus the Pearson correlation is given simply by the  cross-product divided by N. We can write then</p><pre><code class="language-julia hljs">testStatistic(x, Y, i, stat::MyPearsonR; kwargs...) = (x ⋅ Y[i])/length(x)</code></pre><p>That&#39;s it. </p><p>Let&#39;s test our own test. First create some data as example:</p><pre><code class="language-julia hljs">N, M = 7, 100 # N=7 observations, M=100 hypotheses
x=randn(N);
Y=[randn(N) for m=1:M];</code></pre><p>A two-directional exact test, as performed by PermutationTests.jl is obtained by</p><pre><code class="language-julia hljs">println(&quot;correlation test using PermutationsTest.jl: &quot;);
t1 = rMcTest!(x, Y)</code></pre><p>Let&#39;s run our own test. Remind that our test works only for standardized variables, thus we have to input standardized variables. We can use function <a href="../statistics/#PermutationTests.μ0σ1"><code>μ0σ1</code></a>:</p><pre><code class="language-julia hljs">println(&quot;correlation test using our own test: &quot;);
t2 = _permMcTest!(μ0σ1(x), [μ0σ1(y) for y ∈ Y], length(x), MyPearsonR(), PearsonR()) </code></pre><p>Check that the p-values obtained by the two tests is identical:</p><pre><code class="language-julia hljs">abs(sum(t1.p-t2.p))&lt;1e-8 ?  (@info &quot;my test works!&quot;) : 
                            (@error &quot;my test does not work!&quot;)</code></pre><p>Check also the observed statistics:</p><pre><code class="language-julia hljs">abs(sum(t1.obsstat-t2.obsstat))&lt;1e-8 ?  (@info &quot;my test works!&quot;) : 
                                        (@error &quot;my test does not work!&quot;)</code></pre><p>To run a right-directional test:</p><pre><code class="language-julia hljs">t3 = _permMcTest!(μ0σ1(x), [μ0σ1(y) for y ∈ Y], length(x), MyPearsonR(), PearsonR(); 
        fstat = identity) </code></pre><p>To run a left-directional approximate test:</p><pre><code class="language-julia hljs">t4 = _permMcTest!(μ0σ1(x), [μ0σ1(y) for y ∈ Y], length(x), MyPearsonR(), PearsonR(); 
        fstat = identity, switch2rand=1)</code></pre><p>As an excercise, wrap our test in a friendly function that will standardize the input data before running the test. </p><hr/><h3 id="Example-5:-univariate-Chatterjee-correlation"><a class="docs-heading-anchor" href="#Example-5:-univariate-Chatterjee-correlation">Example 5: univariate Chatterjee correlation</a><a id="Example-5:-univariate-Chatterjee-correlation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5:-univariate-Chatterjee-correlation" title="Permalink"></a></h3><p>Examples (4) and (5) are not very interesting per se, as they are just equivalent forms of tests already implemented in the API of <em>PermutationTests.jl</em>. Creating genuinely new tests is not necesserely more complicated thought, as it is shown in this example.</p><p>The Chatterjee (2021) correlation <span>$ξ_{x→y}$</span> is an asymmetric, asymptotycally consistent  estimator of how much a random variable <span>$y$</span> is a measurable function of <span>$x$</span>. Thus, we can use it to test a null hypothesis of the form </p><p><span>$H_0: y≠f(x)$</span>. </p><p>The function <span>$f$</span> does not have to be monotonic, nor linear. In the following, <span>$x$</span> and <span>$y$</span> are assumed continuous with no ties.</p><p>Let <span>$r$</span> be the ranks of variable <span>$y$</span> computed after sorting <span>$y$</span> by ascending  order of <span>$x$</span>. The coefficient is given by</p><p><span>$ξ_{x→y}= 1-\frac{3δ_{x→y}(r)}{n²-1}$</span>, </p><p>where</p><p><span>$δ_{x→y}(r)=\sum_{1}^{n-1}\left| r_{i+1} - r_i \right|$</span></p><p><span>$ξ_{x→y}$</span> takes value in interval <span>$[0, 1]$</span> asymptotically. The limits with finite sampling are <span>$[-1/2+O(1/n), (n-2)/(n+1)]$</span>. </p><p><span>$ξ$</span> has a simple asymptotic Gaussian distribution given by <span>$√n*ξ \sim N(0, 2/5)$</span> and is computed in <span>$O(n\textrm{log}n)$</span>.</p><p><strong>Reference</strong>: S. Chatterjee (2021) a new coefficient of correlation, journal of the american statistical association  116(536), 506-15 </p><hr/><p>Let us now construct a univariate permutation tests for <span>$ξ_{x→y}$</span>. The following code block defines a function to create it:</p><pre><code class="language-julia hljs">using PermutationTests
using StatsBase: ordinalrank # install StatsBase.jl if you don&#39;t have it
import PermutationTests: testStatistic

struct Chatterjeeξ &lt;: Statistic end

testStatistic(r, y, stat::Chatterjeeξ; kwargs...) = sum(abs, diff(r))

xiCorPermTest(x, y; kwargs...) =
   _permTest!(ordinalrank(y[sortperm(x)]), [], length(x), Chatterjeeξ(), PearsonR(); 
                fstat = flip, kwargs...)
</code></pre><p>As in <a href="#Example-3:-univariate-t-test-for-independent-samples">example 3</a>, we import <code>testStatistic</code> and we define a type for the test statistic of interest as a <a href="../PermutationTests/#Statistic"><code>Statistic</code></a> type, which we have named <code>Chatterjeeξ</code>. Notice that we use <span>$δ_{x→y}(r)$</span> as an  equivalent test statistic for <span>$ξ_{x→y}$</span>. Notice also that while this is possible because <span>$δ_{x→y}(r)$</span> and <span>$ξ_{x→y}$</span> are a monotonic function of each other, their relationship is inverted, which will be taken care of later.</p><p>Then, we declare a <a href="#PermutationTests.testStatistic"><code>testStatistic</code></a> method for computing the <span>$δ_{x→y}(r)$</span> quantity defined above for the observed and permuted data.</p><p>Finally, we invoke the <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> function. </p><p>The test works this way: <code>_permTest!</code> takes as input the <span>$n$</span> ranks and list all <span>$n!$</span> permutations of the rank indices for an exact test, or a random number of them for an approximate test. As the ranks are a permutation of <span>$(1.,...,n)$</span> themselves, at each permutation the <code>testStatistic</code> function is invoked and the test statistic is computed directly on the permutation vector, whcih is always passed by <code>_permTest!</code> to <code>testStatistic</code> as the first argument. </p><p>Notice that the test of interest is meaningful only as a right-directional test for <span>$ξ_{x→y}$</span>, but this is a  left-directional test for <span>$δ_{x→y}(r)$</span>, therefore we have used keyword argument <code>fstat = flip</code>. This takes care of the aforementioned inverse relationship of our equivalents statistic.</p><p>Let&#39;s use the test we have created:</p><pre><code class="language-julia hljs">n = 100
x = randn(n)
y = randn(n)
t = xiCorPermTest(x, y) # is not signifant

y = x.^2+randn(length(x))/5
t1 = xiCorPermTest(x, y) # y is a function of x with little noise
</code></pre><hr/><h3 id="Example-6:-multiple-comparisons-Chatterjee-correlation"><a class="docs-heading-anchor" href="#Example-6:-multiple-comparisons-Chatterjee-correlation">Example 6: multiple comparisons Chatterjee correlation</a><a id="Example-6:-multiple-comparisons-Chatterjee-correlation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-6:-multiple-comparisons-Chatterjee-correlation" title="Permalink"></a></h3><hr/><p>Next, let us define the multiple comparisons permutation test for <span>$ξ_{x→y}$</span>. We wish to test simultaneously</p><p><span>$H_0(m): y_m≠f(x), m=1...M$</span></p><p>The code could be:</p><pre><code class="language-julia hljs">using PermutationTests
using StatsBase: ordinalrank # install StatsBase.jl if you don&#39;t have it
import PermutationTests: testStatistic

struct Chatterjeeξ &lt;: Statistic end

testStatistic(p, Y, m::Int, stat::Chatterjeeξ; kwargs...) = 
    1.0-((3*sum(abs, diff(Y[m][p])))/(abs2(length(x))-1))

# Take as input x and Y=y1,...,yM
function xiCorPermMTest(x, Y; kwargs...) 
   p = sortperm(x)
   n = length(x)
   x_ = collect(Base.OneTo(n))
   return _permMcTest!(x_, [ordinalrank(y[p]) for y ∈ Y], n, Chatterjeeξ(), PearsonR(); 
                  fstat = identity, kwargs...)
end                </code></pre><p>The first four lines are to be omitted if we continue writing on the same unit where we have written  the univariate test. </p><p>Again, we define a method for the <code>testStatistic</code> function and we invoke the the <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> function.</p><p>Here we have to adopt a slightly different strategy: <code>testStatistic</code> takes as input the permutation vector and the ranks of the <span>$y_1,..,y_M$</span> vectors. It computes the <span>$ξ_{x→y}$</span> statistic (note: not an equivalent statistic) for these vectors after sorting them all by <strong>the same</strong> sorting key at each permutation, which is the permutation vector passed by <code>_permMcTest!</code> to <code>testStatistic</code> as the <code>x_</code> vector.</p><p>Note that <span>$ξ_{x→y}$</span> can take negative values, thus we pass to <code>_permMcTest!</code> keyword argument <code>fstat = identity</code>; this will result in the correct right-directional test we sought.</p><p>Let&#39;s use the test we have created:</p><pre><code class="language-julia hljs">n = 100
m = 10
x = randn(n)
Y = [randn(n) for i=1:m]
t = xiCorPermMTest(x, Y) # is not signifant

Y = [x.^2+randn(length(x))/5  for i=1:m]
t1 = xiCorPermMTest(x, Y) # y1,...ym are a function of x with little noise
</code></pre><hr/><h3 id="Example-7:-univariate-distance-correlation"><a class="docs-heading-anchor" href="#Example-7:-univariate-distance-correlation">Example 7: univariate distance correlation</a><a id="Example-7:-univariate-distance-correlation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-7:-univariate-distance-correlation" title="Permalink"></a></h3><p>This and next example illustrate how we can crete a test for a complex test statistic, still avoiding redundant computations, as if we wrote the code for a permutation test from scratch.</p><p>The <strong>distance correlation</strong> (Skézely, Rizzo and Bakirov, 2007) extends the concept of correlation to distances among objects living in metric spaces, yielding a measure of dependence that is somehow sensitive to  linear and non-linear dependence. We will here limit ourselves to scalars, vectors and matrices, it does not matter if real or complex.</p><p>Let <span>${(X_k, Y_k): k=1...K}$</span> be <span>$K$</span> pairs of observations (may be scalars, vectors, matrices). The elements within <span>$X$</span> and <span>$Y$</span> must have the same size,  but the size of the elements in <span>$X$</span> may be different from the size of those in <span>$Y$</span>.</p><p>Let <span>$D_x$</span> and <span>$D_y$</span> be the distance matrices with elements</p><p><span>$D_x^{(ij)}=\left| X_i - X_j \right|_p : i,j={1,...,K}$</span></p><p>and</p><p><span>$D_y^{(ij)}=\left| Y_i - Y_j \right|_p : i,j={1,...,K}$</span>,</p><p>where <span>$\left|\cdot\right|_p$</span> is the p-norm, with <span>$p∈(0, 2]$</span>.</p><p>Let </p><p><span>$H=I-K^{-1}\textbf{1}\textbf{1}^T$</span></p><p>be the centering matrix, where <span>$I$</span> is the identity matrix and  <span>$\textbf{1}$</span> is the vector of ones.</p><p>Let</p><p><span>$A=HD_xH&#39;$</span></p><p>and</p><p><span>$B=HD_yH&#39;$</span></p><p>be the double-centered distance matrices. Then the <strong>distance variance</strong> is defined such as</p><p><span>$\nu(X)=\frac{1}{K^2}\sum_{i,j=1}^{K}a_{ij}^2$</span></p><p>and the <strong>distance covariance</strong> such as</p><p><span>$\nu(X, Y)=\frac{1}{K^2}\sum_{i,j=1}^{K}a_{ij}^2b_{ij}^2$</span>.</p><p>Finally, the <strong>distance correlation</strong> is defined such as</p><p><span>$\rho(X, Y)=\frac{\nu(X, Y)}{\sqrt{\nu(X)\nu(Y)}}$</span>,</p><p>where by convention it takes value zero if the denominator is zero.</p><p><strong>Reference</strong>: G.J. Székely, M.L. Rizzo, N.K. Bakirov (2007). Measuring and testing dependence by correlation of distances Ann. Statist. 35(6): 2769-2794.</p><hr/><p>After giving the definition, let us see how we can create a univariate permutation tests for the distance correlation.</p><p>First, let us define some functions we will need.</p><pre><code class="language-julia hljs">
using LinearAlgebra: I, norm, Hermitian, LinearAlgebra

# Distance matrix for an array `X` of scalars, vectors, matrices, etc.
# The `n` elements of `X` can be real or complex.
# `pnorm` is the norm used to get distaces d_ij=norm(X[i]-X[j], pnorm),
# see julia LinearAlgenbra.norm function.
# Return the distance matrix filled only in the upper triangle.
# Note: this is always real.
function dm(x, n; pnorm=2)
    D = Matrix{Float64}(undef, n, n)
    for i=1:n-1 
        @simd for j=i+1:n
            @inbounds D[i, j] = norm(x[i]-x[j], pnorm)
        end
    end
    @simd for i=1:n 
        @inbounds D[i, i] = 0. 
    end
    return D
end    


# x and y are vectors holding n realizations of (real or complex) scalars, vectors, 
# matrices... The elements in y must not have the same dimension as those in x, 
# however x and y must hold the same number of elements.
# Return H*Dx*H&#39; and H*Dy*H&#39;, 
# H is the centering matrices and Dx and Dy are the 
# distance matrices for x and y according to norm `pnorm`. 
function getDistances(x, y; pnorm=2)
    n = length(x)
    H = Matrix{Float64}(I, n, n) - fill(1/n, n, n)
    Hm = LinearAlgebra.Hermitian
    return H * Hm(dm(x, n; pnorm)) * H&#39;, H * Hm(dm(y, n; pnorm)) * H&#39;
end

# As `getDistances`, but here Y is a k-vector of vectors of realizations,
# thus, return H*Dx*H&#39; and H*Dy1*H&#39;,...,H&#39;*Dyk*H&#39;, 
# In addition to the restrictions of `getDistances`, the k vectors of Y must
# contain elements of the same size.
function getMDistances(x, Y; pnorm=2)
    # Centering matrices
    n = length(x)
    H = Matrix{Float64}(I, n, n) - fill(1/n, n, n)
    Hm = LinearAlgebra.Hermitian
    return H * Hm(dm(x, n; pnorm)) * H&#39;, [H * Hm(dm(y, n; pnorm)) * H&#39; for y ∈ Y]
end

# Distance variance. Eq. (2.9) in Székemy, Rizzo and Bakirov(2007). 
# D is a distance matrix
dVar(D) = sum(x-&gt;abs2(x), D)/size(D, 1)^2  

# Distance covariance. Eq. (2.8) in Székemy, Rizzo and Bakirov(2007)
# Dx and Dy are two distance matrices of equal size
dCov(Dx, Dy) = sum(Dx.*Dy)/size(Dx, 1)^2  

# Distance correlation. Eq. (2.10) in Székemy, Rizzo and Bakirov(2007)
# Dx and Dy are two distance matrices of equal size
function dCor(Dx, Dy)
    den = dVar(Dx) * dVar(Dy)
    return den &gt; 0 ? sqrt(dCov(Dx, Dy)/sqrt(den)) : 0.  
end</code></pre><hr/><p>We are now ready to create the univariate test.</p><p>First, let us import <code>testStatistic</code>:</p><pre><code class="language-julia hljs">using PermutationTests
import PermutationTests: testStatistic</code></pre><p>Given two vectors of elements <code>x</code> and <code>y</code> with distance matrices <code>Dx</code> and <code>Dy</code>, the test is  obtained permuting the indices of <code>x</code>. Instead of recomputing distance matrix <code>Dx</code> at each permutation,  the strategy is to permute instead the rows and columns of <code>Dx</code> by a permutation  matrix <code>P</code> that is changed at each permutation according to the permutation vector <code>x</code>.</p><p>Let us then write the function to do this:</p><pre><code class="language-julia hljs"># Overwrite P with a permutation matrix given a vector x holding a 
# permutation of n indices. P must exist, be square and have same dimension as x
function permMatrix!(P, x)
   fill!(P, 0.)
   @simd for i∈axes(P, 1)
         @inbounds P[i, x[i]] = 1. 
   end
   return P
end</code></pre><p>As in the previous examples, we need to define a type for the distance correlation statistic:</p><pre><code class="language-julia hljs">struct Dcor &lt;: Statistic end</code></pre><p>Next, as in the previous example, we need to define a method for <code>testStatistic</code>. This function takes as arguments a permutation vector <code>p</code> and <code>Dy</code>, the distance matrces of <code>y</code>, which is fixed across permutations.</p><p>Furthermore, we will use four specially defined keyword arguments:</p><ul><li><code>H</code> : the centering matrix</li><li><code>P</code> : the permutation matrix (to be updated at each call of the function)</li><li><code>Dx</code>: the original distance matrix for data <code>x</code></li><li><code>dVarDy</code>: the distance variance of <code>y</code></li></ul><p>At each permutation then, we will permute and double-center <code>Dx</code> in order to  compute the distance correlation. The quantities that are invariant by permutation are passed to the function so that we do not need to recompute them.</p><pre><code class="language-julia hljs">function testStatistic(p, Dy, stat::Dcor; H, P, Dx, dVarDy, kwargs...)
   permMatrix!(P, p)
   # Hx * P * Dx * P&#39; * Hx&#39;, Dx with rows and columns permuted
   HxPDxPHx = H * (P * Dx * P&#39;) * H&#39; 
   den = dVar(HxPDxPHx) * dVarDy # square of the denominator of dCor 
   return den &gt; 0 ? sqrt(dCov(HxPDxPHx, Dy)/sqrt(den)) : 0. # dCor
end</code></pre><p>Finally, we write a function preparing the data and calling the <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> function. The preparation involves computing the distance matrices (once and for all), making some checks, creating the permutation vector <code>p</code> and the keyword arguments that will be passed internally to the function <code>testStatistic</code> we have created by <code>_permTest!</code>.</p><p>Importantly, the vector <code>p</code> is created so as to correspond to the permutation yielding the observed statistic (<span>$i.e.$</span>, no data permutation), that is, in this case, the vector with the indices in the natural order <span>$1...n$</span>.</p><pre><code class="language-julia hljs"># The test takes as input two vectors of elements, which may be scalars, vectors or matrices.
function dCorPermTest(x, y; pnorm=2, kwargs...)
   Dx, Dy = getDistances(x, y; pnorm) 
   n = size(Dx, 1)
   size(Dx, 1) == size(Dx, 2) || throw(ArgumentError(&quot;Function dCorPermTest: Did you want to call dCorPermMTest intead? The `Dx` and `Dy` distance matrices that have been computed are not square&quot;))
   size(Dx) == size(Dy) || throw(ArgumentError(&quot;Function dCorPermTest: Did you want to call dCorPermMTest intead? The `Dx` and `Dy` distance matrices that have been computed are not square or do not have the same size&quot;))
   p = collect(Base.OneTo(n)) # permutation vector
   
   #  the centering matrix, the identity matrix, Dx, dVar(Dy)
   Id = Matrix{Float64}(I, n, n)
   H = Id - fill(1/n, n, n) # the centering matrix
   P = copy(Id) # the permutation matrix
   dVarDy = dVar(Dy) # the distance variace of Dy (invariant to permutations)

   return _permTest!(p, Dy, n, Dcor(), PearsonR(); fstat=identity, H, P, Dx, dVarDy, kwargs...)
end</code></pre><p>We are done.</p><p>Let us use the function. We make an example where the elements of <code>x</code> and <code>y</code> are vectors. You can verify yourself that the test works in the same way if they are scalars or matrices.</p><pre><code class="language-julia hljs"># Vectors
n=10
l=20
x=[randn(l) for i=1:n]
y=[randn(l) for i=1:n]
perm = dCorPermTest(x, y; pnorm=2, switch2rand=1)

# non-linear relationship (could be detected)
y=[x_.^2+randn(length(x_))./10 for x_ in x]
perm = dCorPermTest(x, y; switch2rand=1)</code></pre><hr/><h3 id="Example-8:-multiple-comparison-distance-correlation"><a class="docs-heading-anchor" href="#Example-8:-multiple-comparison-distance-correlation">Example 8: multiple comparison distance correlation</a><a id="Example-8:-multiple-comparison-distance-correlation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-8:-multiple-comparison-distance-correlation" title="Permalink"></a></h3><p>This example reuses the code we have already written for the previous <a href="#Example-7:-univariate-distance-correlation">example 7</a>.</p><p>The strategy here is the same as in that example, however here we have to be more careful as there are several keyword arguments that will be updated at each permutation.</p><p>The additional code we need to create a multiple comparisons permutation test is here below. As compared to the previous example, note that:</p><ul><li>we are asking function <code>_permMcTest!</code> to pass internally to the function <code>testStatistic</code> the product <code>HPDxPH</code> as keyword argument because we do not want to compute it for every call of the <code>testStatistic</code> function, but only when it is called for the first hypothesis.</li><li>we are similarly also passing the distance variance of Dx <code>dVarDx</code> as a keyword argument for the same reason.</li></ul><p>Note also</p><ul><li>the sytax <code>[:]</code> to update variables passed as keyword </li><li>the fact that <code>dVarDx</code> is passed as a vector of one element so as to be possible to update it thanks to the syntax <code>[:]</code>.</li></ul><pre><code class="language-julia hljs">function testStatistic(x, DY, m::Int, stat::Dcor; H=H, P=P, Dx, dVarDY, HPDxPH, dVarDx, kwargs...)
    if m==1
        permMatrix!(P, x)
        # Hx * P * Dx * P&#39; * Hx&#39;, Dx with rows and columns permuted 
        HP = H * P
        HPDxPH[:] = HP * Dx * HP&#39;  # notice the [:] syntax; this kwarg is updated when m=1
        dVarDx[:] = [dVar(HPDxPH)] # notice the [:] syntax; this kwarg is updated when m=1
    end
    
    den = dVarDx[1] * dVarDY[m] # dVar(Dx) * dVar(Dy), square of the denominator of dCor 
    return den &gt; 0 ? sqrt(dCov(HPDxPH, DY[m])/sqrt(den)) : 0. # dCor
 end
 

function dCorPermMTest(x, Y; pnorm=2, kwargs...)
    Dx, DY = getMDistances(x, Y; pnorm) 

    # checks
    size(Dx, 1) == size(Dx, 2) || throw(ArgumentError(&quot;Function dCorPermMTest: The `Dx` and `Dy` distance matrices that have been computed are not square&quot;))
    size(Dx) == size(DY[1]) || throw(ArgumentError(&quot;Function dCorPermMTest: The `Dx` and `Dy` distance matrices that have been computed are not square or do not have the same size&quot;))
    length(unique(size.(DY, 1))) == 1 || throw(ArgumentError(&quot;Function dCorPermMTest: All elements of second data input must have equal size&quot;))
    
    n = size(Dx, 1)
    p = collect(Base.OneTo(n)) # permutation vector
    Id = Matrix{Float64}(I, n, n)

    # keyword arguments that are not updated
    H = Id - fill(1/n, n, n)
    dVarDY = [dVar(Dy) for Dy ∈ DY]

    # Initialize keyword arguments that will be updated
    HPDxPH = Matrix{Float64}(undef, size(Dx)...)
    dVarDx = [0.0] # NB, cannot pass a scalar as kwarg if it is to be updated!
    P = copy(Id) # The first permutation must correspond to &#39;no permutation&#39;

    return _permMcTest!(p, DY, n, Dcor(), PearsonR(); 
                        fstat=identity, threaded=false, H, P, Dx, dVarDY, HPDxPH, dVarDx, kwargs...)
 end
</code></pre><hr/><p>Let us use the multiple comaparions test we have just created.</p><p><strong>Example where <code>x</code> and <code>y</code> hold vectors:</strong></p><pre><code class="language-julia hljs"># Vectors
n=10
l=20
m=30
x=[randn(l) for i=1:n]
Y=[[randn(l) for i=1:n] for j=1:m]
# random data. No hypothesis should be significant
perm = dCorPermMTest(x, Y)

# The y1...ym variables are noisy copy of x.  
# The p-value should be significant for about the first M/2 hypothesis out of M.
# The actual number of rejected hypotheses could be slighty different then M/2. 
for i=1:m÷2
    Y[i]=[x[j].+randn(l)./2 for j=1:n]
end
perm = dCorPermMTest(x, Y)</code></pre><p><strong>Example where <code>x</code> and <code>y</code> hold matrices:</strong></p><pre><code class="language-julia hljs"># Matrices
n=10
l=20
m=30
x=[randn(l, l) for i=1:n]
Y=[[randn(l, l) for i=1:n] for j=1:m]
# random data. No hypothesis should be significant
perm = dCorPermMTest(x, Y)

# The y1...ym variables are noisy copy of x.  
# The p-value should be significant for about the first M/2 hypothesis out of M
# The actual number of rejected hypotheses could be slighty different then M/2. 
for i=1:m÷2
    Y[i]=[x[j].+randn(l, l)./2 for j=1:n]
end
perm = dCorPermMTest(x, Y)
</code></pre><hr/><p>In conclusion, in the above examples we have illustrated how to create permutation tests of increasing complexity. The last two examples concerns tests that are pretty complex and very different from any of the test implemented in <em>Permutationtests.jl</em>, where even the permutation scheme had to be defined differently. The diverse procedures exposed here above can be adapted to new problems in order to create a countless number of new permutation tests.</p><h2 id="Useful-functions-for-creating-your-own-tests"><a class="docs-heading-anchor" href="#Useful-functions-for-creating-your-own-tests">Useful functions for creating your own tests</a><a id="Useful-functions-for-creating-your-own-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-functions-for-creating-your-own-tests" title="Permalink"></a></h2><hr/><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PermutationTests._permTest!" href="#PermutationTests._permTest!"><code>PermutationTests._permTest!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function _permTest!(x, y, ns::nsType, stat::Stat, asStat::AsStat;
                    standardized::Bool=false, centered::Bool=false, 
                    nperm::Int = 20000, 
                    fstat::Function = abs,
                    compfunc::Function = &gt;=,
                    switch2rand::Int = Int(1e8),
                    seed::Int = 1234,
                    verbose::Bool = true,
                    cpcd = nothing,
                    kwargs...) where {Stat&lt;:Statistic, AsStat&lt;:Statistic}</code></pre><p>This function ultimately performs all <strong>univariate permutation tests</strong> implemented in <em>PermutationsTests.jl</em>,  both <em>exact</em> and <em>approximate</em> (Monte Carlo). </p><p>For running tests use the <a href="../univariate tests/#Univariate-tests">univariate test functions</a>. You need this function only for <a href="#Create-your-own-test">creating your own tests</a>.</p><p>Rewrite <code>x</code> and/or <code>y</code>, depending on the test performed.</p><p>For the <code>ns</code> argument see <a href="../tools/#ns">ns</a>.</p><p><code>stat</code> can be a singleton of the <a href="../PermutationTests/#Statistic">Statistic</a> type or a user-defined singleton of this type  to be used as argument of a function implemented by the user to compute both the observed and permuted test statistics, see <a href="#Create-your-own-test">create your own test</a>.</p><p><code>asStat</code> is a singleton of the <a href="../PermutationTests/#Statistic">Statistic</a> type. It is used to determine the permutation scheme  and for this purpose it will be internally passed to <a href="../tools/#PermutationTests.genPerms"><code>genPerms</code></a> and <a href="../tools/#PermutationTests.nrPerms"><code>nrPerms</code></a>.</p><p><code>asStat</code> determines also the input data format if you declare your own <code>stat</code> type. In this case the function you write for computing the observed and permuted test statistic will take the <code>x</code> and  <code>y</code> arguments as it follows: </p><p>For <code>Stat</code> belonging to <a href="../PermutationTests/#Statistic-groups">group</a></p><ul><li><code>BivStatistic</code> : <code>x</code>, <code>y</code> are the two vectors of <span>$N$</span> elements each for which the bivariate statistic is to be tested. <code>ns</code> is ignored.</li><li><code>IndSampStatistic</code> : we have <span>$K$</span> groups and <span>$N=N_1+...+N_K$</span> total observations; <code>y</code> holds all observations in a single vector such as <code>[y1;...;yK]</code> and <code>x</code> is the <a href="#PermutationTests.membership"><code>membership(::IndSampStatistic)</code></a> vector. For example, for <span>$K=2$</span>, <span>$N_1=2$</span> and <span>$N_2=3$</span>, <code>x=[1, 1, 2, 2, 2]</code>.</li><li><code>RepMeasStatistic</code> : we have <span>$K$</span> measures (<em>e.g.</em>, treatements) and <span>$N$</span> subjects; <code>y</code> holds the  <span>$K*N$</span> observations in a single vector such as <code>[y1;...;yN]</code>, where each vector <span>$y_i$</span>, for <span>$i=1...N$</span>, holds the observation at the <span>$K$</span> treatments and <code>x=collect(1:K*N)</code> (see <a href="#PermutationTests.membership"><code>membership(::RepMeasStatistic)</code></a>).</li><li><code>OneSampStatistic</code> : We have <span>$N$</span> observations (<em>e.g.</em>, subjects); <code>y</code> holds the <span>$N$</span> observations and <code>x=ones(Int, N)</code> (see <a href="#PermutationTests.membership"><code>membership(::OneSampStatistic)</code></a>).</li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>In all cases <code>x</code> is treated as the permutation vector that will be permuted before calling the <a href="#PermutationTests.testStatistic"><code>testStatistic</code></a> function.</p></div></div><p>For <code>length(x)&gt;30</code> the approximate test is performed in all cases, </p><p>otherwise,</p><p>if the number of systematic permutations exceeds <code>switch2rand</code> the approximate test is performed  using <code>nperm</code> random permutations (default 20000), </p><p>otherwise, </p><p>the exact test is performed. </p><p><code>switch2rand</code> defaults to 1e8.  To perform approximate tests in all cases, set <code>switch2rand</code>, for example, to 1. </p><p>If <code>stat</code> is a <code>BivStatistic</code>, it optionally uses kwargs <code>standardized</code> or <code>centered</code> to compute them faster, see for example <a href="../univariate tests/#PermutationTests.correlationTest"><code>correlationTest</code></a>.</p><p><code>seed</code> is the initial seed for generating random permutations (not used for exact tests).  To use a random seed, pass <code>seed=0</code>. For <code>seed</code> any natural number, the test will be reproducible.</p><p><code>fstat</code> is a function applied to the test statistic. By default this is the julia <code>abs</code> function,  which takes the absolute value, hence yieds a bi-directional test for a test statistic distributed symmetrically around zero. For a right-directional test using such test statistics pass here <code>identity</code>.  For a left-directional using such test statistics pass here <a href="#PermutationTests.flip"><code>flip</code></a>.</p><p><code>compfunc</code> is the function to compare the observed statistics to the permuted statistics.  The default function is <code>&gt;=</code>. Don&#39;t change it unless you have studied the code of the function.</p><p>If <code>verbose</code> is true, print some information in the REPL while running the test.  Set to false if you run benchmarks. The default is true.</p><p>For the <code>cpcd</code> and <code>kwargs...</code> argument, see <a href="#Create-your-own-test">create you own test</a>.</p><p>Return a <a href="../PermutationTests/#UniTest">UniTest</a> structure.</p><p><em>Examples</em></p><pre><code class="language-julia hljs">using PermutationTests
x=randn(6)
y=randn(6) 
# bi-directional exact test of the correlation between x and y
t8 = _permTest!(μ0(x), μ0(y), length(x), Covariance(), Covariance(); centered=true) 
t8.p
t8.stat
#...

# make a left-directional test and standardize the data
t8_2 = _permTest!(μ0σ1(x), μ0σ1(y), length(x), Covariance(), Covariance(); 
        standardized=true, fstat=flip) 

# the same but force an approximate test
t8_3 = _permTest!(μ0σ1(x), μ0σ1(y), length(x), Covariance(), Covariance(); 
        standardized=true, fstat=flip, switch2rand=1) 

# the same using 5000 random permutations
t8_4 = _permTest!(μ0σ1(x), μ0σ1(y), length(x), Covariance(), Covariance(); 
        standardized=true, fstat=flip, switch2rand=1, nperm=5000) </code></pre><p>To check more examples, see the <em>uniTests_API.jl</em> unit located in the <em>src</em> github folder and function <code>test_unitests()</code> in the <em>runtests.jl</em> unit located in the <em>test</em> github folder.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/1a4187b95195688f3daf7bcb4e2b8cde207de80b/src/uniTests.jl#L71-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PermutationTests._permMcTest!" href="#PermutationTests._permMcTest!"><code>PermutationTests._permMcTest!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function _permMcTest!(x, Y, ns::nsType, stat::Stat, asStat::AsStat;
            standardized::Bool=false, centered::Bool=false, 
            stepdown::Bool = true,
            fwe::Float64 = 0.05,
            nperm::Int = 20000, 
            fstat::Function = abs,
            compfunc::Function = &gt;=,
            switch2rand::Int = Int(1e8),
            seed::Int = 1234,
            threaded::Bool = Threads.nthreads()&gt;=4,
            verbose::Bool = true,
            cpcd = nothing) where {Stat&lt;:Statistic, AsStat&lt;:Statistic}</code></pre><p>This function ultimately performs all <strong>multiple comparisons permutation tests</strong> implemented in <em>PermutationsTests.jl</em>,  both <em>exact</em> and <em>approximate</em> (Monte Carlo). </p><p>For running tests use the <a href="../multiple comparisons tests/#Multiple-comparisons-tests">multiple comparisons test functions</a>. You need this function only for <a href="#Create-your-own-test">creating your own tests</a>.</p><p>The step-down version of the test is performed if <code>stepdown</code> is true (default). In this case the <code>fwe</code> (family-wise error) rate is used for rejection at each step (default=0.05).</p><p>Rewrite <code>x</code> and/or <code>Y</code>, depending on the test performed.</p><p>For the <code>ns</code> argument see <a href="../tools/#ns">ns</a>.</p><p><code>stat</code> can be a singleton of the <a href="../PermutationTests/#Statistic">Statistic</a> type or a user-defined singleton of this type  to be used as argument of two functions implemented by the user to compute the observed and permuted test statistics, see <a href="#Create-your-own-test">create your own test</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In contrast to univariate tests, equivalent statistics are not possible for multiple comparison tests,  with the exception of <code>CrossProd()</code> if the data has been standardized and <code>Covariance()</code> if the data  has been centered and those only for correlation-like tests.</p><p>The test statistics that must be used as <code>Stat</code> for the other kinds of test if a singleton of the  <a href="../PermutationTests/#Statistic">Statistic</a> type is used are <code>AnovaF_IS()</code>, <code>StudentT_IS()</code>, <code>AnovaF_RM()</code>, and <code>StudentT_1S()</code>.</p></div></div><p><code>asStat</code> is a singleton of the <a href="../PermutationTests/#Statistic">Statistic</a> type. It is used to determine the permutation scheme  and for this purpose it will be passed to <a href="../tools/#PermutationTests.genPerms"><code>genPerms</code></a> and <a href="../tools/#PermutationTests.nrPerms"><code>nrPerms</code></a>.</p><p><code>asStat</code> determines also the input data format if you declare your own <code>stat</code> type. In this case the two functions you write for computing the observed and permuted statistics will take the <code>x</code> and  <code>Y</code> arguments as it follows. </p><p>For <code>Stat</code> belonging to <a href="../PermutationTests/#Statistic-groups">group</a></p><ul><li><code>BivStatistic</code> : <code>x</code> is a fixed vector with <span>$N$</span> elements and <code>Y</code> an an <span>$M$</span>-vector of <span>$N$</span>-vectors. The <span>$M$</span> bivariate statistics between <code>x</code> and the <span>$y_m$</span> vectors of <code>Y</code> are tested simultaneously. <code>ns</code> is ignored.</li><li><code>IndSampStatistic</code> : we have <span>$K$</span> groups and <span>$N=N_1+...+N_K$</span> total observations; <code>Y</code> is an <span>$M$</span>-vector, each one holding all observations for the <span>$m^{th}$</span> hypothesis in a single vector. The <span>$m^{th}$</span> vector <span>$y_m$</span> concatenates the observations for all groups such as [y[m][1];...;y[m][K]]. <code>x</code> is the <a href="#PermutationTests.membership"><code>membership(::IndSampStatistic)</code></a> vector, common to all hypotheses. For example, for <span>$K=2$</span>, <span>$N_1=2$</span> and <span>$N_2=3$</span>, <code>x=[1, 1, 2, 2, 2]</code>. </li><li><code>RepMeasStatistic</code> : we have <span>$K$</span> measures (<em>e.g.</em>, treatements) and <span>$N$</span> subjects; <code>Y</code> is an M-vector, each one holding the <span>$K*N$</span> observations for the <span>$m^{th}$</span> hypothesis in a single vector. The <span>$m^{th}$</span> vector <span>$y_m$</span> is such as <code>[Y[m][1];...;Y[m][N]]</code>, where each vector Y[1][n], for <span>$n=1…N$</span>, holds the observations for the <span>$K$</span> treatments and <code>x=collect(1:K*N)</code> (see <a href="#PermutationTests.membership"><code>membership(::RepMeasStatistic)</code></a>). </li><li><code>OneSampStatistic</code> : We have <span>$N$</span> observations (<em>e.g.</em>, subjects); <code>Y</code> is an <span>$M$</span>-vector, each one holding the <span>$N$</span> observations and <code>x=ones(Int, N)</code> (see <a href="#PermutationTests.membership"><code>membership(::OneSampStatistic)</code></a>).</li></ul><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>In all cases <code>x</code> is treated as the permutation vector that will be permuted before calling the <a href="#PermutationTests.testStatistic"><code>testStatistic</code></a> function for each of the elements in <code>Y</code>.</p></div></div><p>Optional keyword arguments <code>switch2rand</code>, <code>nperm</code>, <code>standardized</code>, <code>centered</code>, <code>seed</code>, <code>fstat</code>, <code>compfunc</code> and <code>verbose</code> have the same meaning as in the <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> function.</p><p>If <code>threaded</code> is true (default) the function is multi-threaded if the product of the number of hypotheses,      observations, and permutations exceed 500 millions. If you have unexpected problems with the function, try setting <code>threaded</code> to false.</p><p>For the <code>cpcd</code> and <code>kargs...</code> arguments, see <a href="#Create-your-own-test">create you own test</a>.</p><p>Return a <a href="../PermutationTests/#MultcompTest">MultcompTest</a> structure.</p><p>The number of executed steps <span>$S$</span> can be retrived as the length of the <code>.rejections</code> field  of the returned structure. </p><p><em>Examples</em></p><pre><code class="language-julia hljs">using PermutationTests
N, M = 8, 100 # 100 hypotheses, N=8
x=randn(N)
Y=[randn(N) for m=1:M]
# bi-directional exact test of the correlation between x and 
# all the M vector in Y.
T12 = _permMcTest!(x, Y, N, PearsonR(), PearsonR())
T12.p
T12.stat
#...

# bi-directional exact test. Faster test by data standardization 
T12_2 = _permMcTest!(μ0σ1(x), [μ0σ1(y) for y in Y], N, CrossProd(), PearsonR(); 
                    standardized=true) 

# left-directional exact test.
T12_3 = _permMcTest!(μ0σ1(x), [μ0σ1(y) for y in Y], N, CrossProd(), PearsonR(); 
                    standardized=true, fstat=flip)

# as above, but force an approximate test
T12_4 = _permMcTest!(μ0σ1(x), [μ0σ1(y) for y in Y], N, CrossProd(), PearsonR(); 
                    standardized=true, fstat=flip, switch2rand=1)

# the same using 5000 random permutations
T12_4 = _permMcTest!(μ0σ1(x), [μ0σ1(y) for y in Y], N, CrossProd(), PearsonR(); 
                    standardized=true, fstat=flip, switch2rand=1, nperm=5000)</code></pre><p>To check more examples, see the <em>multcompTests_API.jl</em> unit located in the <em>src</em> github folder and function <code>test_multicompTests()</code> in the <em>runtests.jl</em> unit located in the <em>test</em> github folder.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/1a4187b95195688f3daf7bcb4e2b8cde207de80b/src/multcompTests.jl#L110-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PermutationTests.flip" href="#PermutationTests.flip"><code>PermutationTests.flip</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flip(x::Bool)

flip(x::Union{R, I}) where {R&lt;:Real, I&lt;:Int}</code></pre><p>Invert the sign of a real number or integer and negate a boolean. </p><p>This function may be needed for argument <code>fstat</code> to call <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> or <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> if you  <a href="#Create-your-own-test">create your own test</a> - see the example on how to create a test for the <a href="#Example-5:-univariate-Chatterjee-correlation">Chatterjee correlation</a>.</p><p>It can also be useful when you create a new test in the code you deveolop for computing your own test statistics. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/1a4187b95195688f3daf7bcb4e2b8cde207de80b/src/tools.jl#L39-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PermutationTests.membership" href="#PermutationTests.membership"><code>PermutationTests.membership</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function membership(stat::IndSampStatistic, ns::Vector{Int})</code></pre><p>Create the appropriate argument <code>x</code> to be used by functions <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> and <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> when you  <a href="#Create-your-own-test">create your own test</a> using the permutation scheme of test statistics belonging  to the <code>IndSampStatistic</code> <a href="../PermutationTests/#Statistic-groups">group</a>.</p><p>For <code>stat</code> a <code>IndSampStatistic</code>, <code>ns</code> is a group numerosity vector, <em>i.e.</em>, a vector of positive integers  <code>[N1,...,NK]</code>, where <span>$K$</span> is the number of groups and <span>$N_k$</span> is the number of observations for the <span>$k^{th}$</span> group (see <a href="../tools/#ns">ns</a>).  </p><p>Return the group membership vector <code>[repeat (1, N1);...; repeat(K, Nk)]</code></p><p>If <code>rev=reverse</code> is passed as keyword argument, return instead group membership vector <code>[repeat (K, N1);...; repeat(1, Nk)]</code>. This is used to run t-tests for independent samples using the <code>PearsonR()</code> <a href="../PermutationTests/#Statistic">Statistic</a>, see for example <a href="../univariate tests/#PermutationTests.studentTestIS"><code>studentTestIS</code></a>.</p><p><em>Examples</em></p><pre><code class="language-julia hljs">using PermutationsTests
membership(AnovaF_IS(), [3, 4])
# return the vector [1, 1, 1, 2, 2, 2, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/1a4187b95195688f3daf7bcb4e2b8cde207de80b/src/tools.jl#L312-L336">source</a></section><section><div><pre><code class="language-julia hljs">function membership(stat::RepMeasStatistic, ns::@NamedTuple{n::Int, k::Int})</code></pre><p>Create the appropriate argument <code>x</code> to be used by functions <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> and <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> when you  <a href="#Create-your-own-test">create your own test</a> using the permutation scheme of test statistics belonging  to the <code>RepMeasStatistic</code> <a href="../PermutationTests/#Statistic-groups">group</a>.</p><p>For <code>stat</code> a <code>RepMeasStatistic</code>, <code>ns</code> is a named tuple, such as <code>(n=N, k=K)</code>, where <span>$N$</span> is the number of observations (e.g., <em>subjects</em>) and <span>$K$</span> the number of measurements (or <em>treatments</em>, <em>times</em>, ect.), see <a href="../tools/#ns">ns</a>.</p><p>Return <code>collect(1:N*K)</code>.</p><p><em>Examples</em></p><pre><code class="language-julia hljs">using PermutationsTests
membership(AnovaF_RM(), (n=2, k=4))
# return the vector [1, 2, 3, 4, 5, 6, 7, 8]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/1a4187b95195688f3daf7bcb4e2b8cde207de80b/src/tools.jl#L340-L359">source</a></section><section><div><pre><code class="language-julia hljs">function membership(stat::OneSampStatistic, ns::Int)</code></pre><p>Create the appropriate argument <code>x</code> to be used by functions <a href="#PermutationTests._permTest!"><code>_permTest!</code></a> and <a href="#PermutationTests._permMcTest!"><code>_permMcTest!</code></a> when you  <a href="#Create-your-own-test">create your own test</a> using the permutation scheme of test statistics belonging  to the <code>OneSampStatistic</code> <a href="../PermutationTests/#Statistic-groups">group</a>.</p><p>For <code>stat</code> a <code>OneSampStatistic</code>, <code>ns</code> is the number of observations (e.,g., <em>subjects</em>) given as an integer, see <a href="../tools/#ns">ns</a>.</p><p>Return <code>ones(Int, ns)</code>.</p><p><em>Examples</em></p><pre><code class="language-julia hljs">using PermutationsTests
membership(Sum(), 5)
# return the vector [1, 1, 1, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/1a4187b95195688f3daf7bcb4e2b8cde207de80b/src/tools.jl#L362-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PermutationTests.testStatistic" href="#PermutationTests.testStatistic"><code>PermutationTests.testStatistic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">
# METHOD 1
function testStatistic(x, y, stat::mystat, fstat::Function; 
                        cpcd=nothing, kwargs...)

# METHOD 2
function testStatistic(x, Y, i::Int, stat::mystat, fstat::Function; 
                        cpcd=nothing, kwargs...)
                        
        where mystat&lt;:Statistic </code></pre><p>Compute the observed and permuted test statistic for univariate tests (Method 1) or the <span>$i^{th}$</span>  observed and permuted test statistic for the <span>$i^{th}$</span> hypothesis, with <span>$i=1...M$</span>,  for multiple comparisons permutation tests (Method 2).</p><p>If you <a href="#Create-your-own-test">create your own test</a> you will write new methods for these functions taking as <code>stat</code> a test statistic of type <a href="../PermutationTests/#Statistic">Statistic</a> you have declared.</p><p>If not, you never need these functions.</p><p><code>Y</code> is a vector of elements (typically, vectors themelves) and the test-statistic is to be computed on <code>Y[i]</code>, using the permutation vector <code>x</code>.</p><p>For the <code>fstat</code> and <code>cpcd</code> argument, see how to <a href="#Create-your-own-test">create your own test</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/PermutationTests.jl/blob/1a4187b95195688f3daf7bcb4e2b8cde207de80b/src/multcompTests.jl#L68-L96">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../test statistics/">« Test statistics</a><a class="docs-footer-nextpage" href="../chose a test/">Chose a Test »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 15 July 2024 07:40">Monday 15 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
